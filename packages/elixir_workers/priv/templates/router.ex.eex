defmodule <%= @app_module %>.Router do
  use ElixirWorkers.Router

  alias ElixirWorkers.{Conn, KV, D1}

  defp routes do
    [
      # SPA shell — serves full HTML on first load, all navigation via JS
      {"GET", [], &page_shell/1},
      {"GET", ["login"], &page_shell/1},
      {"GET", ["signup"], &page_shell/1},
      {"GET", ["app"], &page_shell_auth/1},
      {"GET", ["profile"], &page_shell_auth/1},
      {"GET", ["profile", ":id"], &page_shell_auth/1},
      {"GET", ["messages"], &page_shell_auth/1},
      {"GET", ["messages", ":id"], &page_shell_auth/1},
      {"GET", ["tokens"], &page_shell_auth/1},
      {"GET", ["admin"], &page_shell_auth/1},
      {"GET", ["settings"], &page_shell_auth/1},

      # Fragment endpoints — return HTML partials for SPA navigation
      {"GET", ["_fragment", "landing"], &frag_landing/1},
      {"GET", ["_fragment", "login"], &frag_login/1},
      {"GET", ["_fragment", "signup"], &frag_signup/1},
      {"GET", ["_fragment", "map"], &frag_map/1},
      {"GET", ["_fragment", "profile"], &frag_profile/1},
      {"GET", ["_fragment", "profile", ":id"], &frag_profile_view/1},
      {"GET", ["_fragment", "messages"], &frag_messages/1},
      {"GET", ["_fragment", "messages", ":id"], &frag_conversation/1},
      {"GET", ["_fragment", "tokens"], &frag_tokens/1},
      {"GET", ["_fragment", "admin"], &frag_admin/1},
      {"GET", ["_fragment", "settings"], &frag_settings/1},

      # Static assets
      {"GET", ["app.js"], &asset_js/1},
      {"GET", ["app.css"], &asset_css/1},

      # API — health
      {"GET", ["api", "health"], &api_health/1},

      # API — location
      {"POST", ["api", "location"], &api_location_update/1},
      {"GET", ["api", "nearby"], &api_nearby/1},

      # API — profile photos (must be before :id routes)
      {"GET", ["api", "profile", "photos"], &api_profile_photos_list/1},
      {"POST", ["api", "profile", "photos"], &api_profile_photos_add/1},
      {"DELETE", ["api", "profile", "photos", ":id"], &api_profile_photos_delete/1},

      # API — profile
      {"GET", ["api", "profile", ":id"], &api_profile_get/1},
      {"PUT", ["api", "profile"], &api_profile_update/1},

      # API — messages
      {"POST", ["api", "messages"], &api_message_send/1},
      {"GET", ["api", "messages", ":id"], &api_conversation/1},
      {"GET", ["api", "messages", ":id", "newer"], &api_conversation_newer/1},
      {"GET", ["api", "messages", ":id", "older"], &api_conversation_older/1},
      {"GET", ["api", "conversations"], &api_conversations/1},
      {"POST", ["api", "messages", ":id", "read"], &api_mark_read/1},
      {"POST", ["api", "messages", ":id", "typing"], &api_typing/1},

      # API — tokens
      {"GET", ["api", "tokens"], &api_tokens_get/1},
      {"POST", ["api", "tokens", "purchase"], &api_tokens_purchase/1},
      {"POST", ["api", "tokens", "daily"], &api_tokens_daily/1},
      {"GET", ["api", "tokens", "history"], &api_tokens_history/1},

      # API — moderation
      {"POST", ["api", "report"], &api_report/1},
      {"POST", ["api", "block"], &api_block/1},
      {"DELETE", ["api", "block"], &api_unblock/1},
      {"GET", ["api", "blocks"], &api_blocks_list/1},

      # API — notifications
      {"GET", ["api", "notifications", "unread"], &api_unread_count/1},

      # API — anti-spam
      {"POST", ["api", "spam", "check"], &api_spam_check/1},

      # API — public stats (landing page hero)
      {"GET", ["api", "stats"], &api_public_stats/1},

      # API — admin
      {"GET", ["api", "admin", "stats"], &api_admin_stats/1}
    ]
  end

  # --- Auth helpers ---

  defp get_auth(conn) do
    conn["_state"]["auth"]
  end

  defp require_auth(conn) do
    case get_auth(conn) do
      nil -> {:error, Conn.redirect(conn, "/login")}
      auth -> {:ok, conn, auth}
    end
  end

  defp require_auth_api(conn) do
    case get_auth(conn) do
      nil -> {:error, Conn.json(conn, 401, %{"error" => "unauthorized"})}
      auth -> {:ok, conn, auth}
    end
  end

  defp require_admin(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> {:error, conn}
      {:ok, conn, auth} ->
        # Check admin status via env var ADMIN_EMAILS (comma-separated)
        admin_emails = conn["_state"]["_admin_emails"] || ""
        email = auth["email"] || ""
        if admin_email?(admin_emails, email) do
          {:ok, conn, auth}
        else
          {:error, Conn.json(conn, 403, %{"error" => "forbidden"})}
        end
    end
  end

  defp admin_email?(_admin_str, email) when byte_size(email) == 0, do: false
  defp admin_email?(admin_str, _email) when byte_size(admin_str) == 0, do: false
  defp admin_email?(admin_str, email) do
    # Check if email appears in comma-separated admin list
    check_csv_member(admin_str, email)
  end

  defp check_csv_member(csv, target) do
    csv_trimmed = trim_spaces(csv)
    case :binary.match(csv_trimmed, ",") do
      :nomatch -> trim_spaces(csv_trimmed) == target
      {pos, _} ->
        head = trim_spaces(:binary.part(csv_trimmed, 0, pos))
        rest = :binary.part(csv_trimmed, pos + 1, byte_size(csv_trimmed) - pos - 1)
        head == target or check_csv_member(rest, target)
    end
  end

  defp trim_spaces(<<32, rest::binary>>), do: trim_spaces(rest)
  defp trim_spaces(str), do: trim_trailing(str)
  defp trim_trailing(<<>>), do: <<>>
  defp trim_trailing(str) do
    len = byte_size(str)
    case :binary.at(str, len - 1) do
      32 -> trim_trailing(:binary.part(str, 0, len - 1))
      _ -> str
    end
  end

  # --- Rate limiting helper ---

  defp check_rate_limit(conn, key, max_count, window_seconds) do
    now = conn["_state"]["_now"] || ""
    {conn, existing} = D1.query_one(conn, "DB",
      "SELECT count, window_start FROM rate_limits WHERE key = ? AND expires_at > ?",
      [key, now])

    case existing do
      nil ->
        expires = window_seconds
        conn = D1.exec(conn, "DB",
          "INSERT OR REPLACE INTO rate_limits (key, count, window_start, expires_at) VALUES (?, 1, datetime('now'), datetime('now', '+' || ? || ' seconds'))",
          [key, expires])
        {:ok, conn, max_count - 1}
      r ->
        count = r["count"] || 0
        if count >= max_count do
          {:error, conn, 0}
        else
          conn = D1.exec(conn, "DB",
            "UPDATE rate_limits SET count = count + 1 WHERE key = ?", [key])
          {:ok, conn, max_count - count - 1}
        end
    end
  end

  # --- Anti-spam helper ---

  defp check_spam(body) do
    hp = body["_hp"] || ""
    timing = body["_timing"]
    entropy = body["_entropy"]

    cond do
      byte_size(hp) > 0 -> {:spam, "honeypot"}
      is_number(timing) and timing < 500 -> {:suspicious, "fast_submit"}
      is_number(entropy) and entropy == 0 -> {:suspicious, "no_mouse"}
      true -> :ok
    end
  end

  # --- SPA shell pages ---

  defp page_shell(conn) do
    auth = get_auth(conn)
    if auth != nil do
      Conn.redirect(conn, "/app")
    else
      path = conn["url"] || "/"
      path = case :binary.match(path, "?") do
        {pos, _} -> :binary.part(path, 0, pos)
        :nomatch -> path
      end

      route = case path do
        "/login" -> "login"
        "/signup" -> "signup"
        _ -> "landing"
      end

      Conn.html(conn, 200, <%= @app_module %>.Views.spa_shell(nil, route))
    end
  end

  defp page_shell_auth(conn) do
    case require_auth(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        path = conn["url"] || "/app"
        path = case :binary.match(path, "?") do
          {pos, _} -> :binary.part(path, 0, pos)
          :nomatch -> path
        end

        route = cond do
          path == "/app" -> "map"
          path == "/profile" -> "profile"
          path == "/messages" -> "messages"
          path == "/tokens" -> "tokens"
          path == "/admin" -> "admin"
          path == "/settings" -> "settings"
          :binary.match(path, "/profile/") != :nomatch -> "profile-view"
          :binary.match(path, "/messages/") != :nomatch -> "conversation"
          true -> "map"
        end

        Conn.html(conn, 200, <%= @app_module %>.Views.spa_shell(auth, route))
    end
  end

  # --- Fragment endpoints (HTML partials for SPA) ---

  defp frag_landing(conn) do
    Conn.html(conn, 200, <%= @app_module %>.Views.frag_landing())
  end

  defp frag_login(conn) do
    Conn.html(conn, 200, <%= @app_module %>.Views.frag_login())
  end

  defp frag_signup(conn) do
    Conn.html(conn, 200, <%= @app_module %>.Views.frag_signup())
  end

  defp frag_map(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_map(auth))
    end
  end

  defp frag_profile(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        {conn, profile} = D1.query_one(conn, "DB",
          "SELECT * FROM profiles WHERE user_id = ?", [auth["userId"]])
        {conn, photos} = D1.query(conn, "DB",
          "SELECT id, url, position FROM profile_photos WHERE user_id = ? ORDER BY position ASC",
          [auth["userId"]])
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_profile_edit(auth, profile || %{}, photos || []))
    end
  end

  defp frag_profile_view(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        id = conn["path_params"]["id"]
        uid = auth["userId"]
        # Check if blocked (either direction)
        {conn, block} = D1.query_one(conn, "DB",
          "SELECT 1 as b FROM blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)",
          [uid, id, id, uid])
        if block != nil do
          Conn.html(conn, 403, "<div class=\"dp-container dp-page dp-center\"><h1>Blocked</h1><p class=\"dp-muted\">This profile is not available</p></div>")
        else
          {conn, profile} = D1.query_one(conn, "DB",
            "SELECT p.* FROM profiles p WHERE p.user_id = ?", [id])
          case profile do
            nil -> Conn.html(conn, 404, "<div class=\"dp-container dp-page dp-center\"><h1>404</h1><p class=\"dp-muted\">User not found</p></div>")
            _ ->
              {conn, photos} = D1.query(conn, "DB",
                "SELECT id, url, position FROM profile_photos WHERE user_id = ? ORDER BY position ASC", [id])
              Conn.html(conn, 200, <%= @app_module %>.Views.frag_profile_view(auth, profile, photos || []))
          end
        end
    end
  end

  defp frag_messages(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, convos} = D1.query(conn, "DB",
          "SELECT m.content, m.created_at, m.from_id, m.to_id, m.read, p.display_name, p.avatar_url, CASE WHEN m.from_id = ? THEN m.to_id ELSE m.from_id END as other_id FROM messages m LEFT JOIN profiles p ON p.user_id = CASE WHEN m.from_id = ? THEN m.to_id ELSE m.from_id END WHERE m.id IN (SELECT MAX(id) FROM messages WHERE from_id = ? OR to_id = ? GROUP BY CASE WHEN from_id = ? THEN to_id ELSE from_id END) ORDER BY m.created_at DESC LIMIT 50",
          [uid, uid, uid, uid, uid])
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_messages(auth, convos || []))
    end
  end

  defp frag_conversation(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        # Check if blocked
        {conn, block} = D1.query_one(conn, "DB",
          "SELECT 1 as b FROM blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)",
          [uid, other_id, other_id, uid])
        if block != nil do
          Conn.html(conn, 403, "<div class=\"dp-container dp-page dp-center\"><h1>Blocked</h1><p class=\"dp-muted\">This conversation is not available</p></div>")
        else
          {conn, msgs} = D1.query(conn, "DB",
            "SELECT m.id, m.from_id, m.to_id, m.content, m.media_url, m.message_type, m.read, m.created_at, p.display_name FROM messages m LEFT JOIN profiles p ON p.user_id = m.from_id WHERE (m.from_id = ? AND m.to_id = ?) OR (m.from_id = ? AND m.to_id = ?) ORDER BY m.id DESC LIMIT 50",
            [uid, other_id, other_id, uid])
          {conn, other_profile} = D1.query_one(conn, "DB",
            "SELECT * FROM profiles WHERE user_id = ?", [other_id])

          conn = D1.exec(conn, "DB",
            "UPDATE messages SET read = 1 WHERE to_id = ? AND from_id = ? AND read = 0",
            [uid, other_id])

          reversed = reverse_list(msgs || [])
          Conn.html(conn, 200, <%= @app_module %>.Views.frag_conversation(auth, other_profile || %{}, reversed))
        end
    end
  end

  defp frag_tokens(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        {conn, tokens} = D1.query_one(conn, "DB",
          "SELECT * FROM tokens WHERE user_id = ?", [auth["userId"]])
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_tokens(auth, tokens || %{}))
    end
  end

  defp frag_admin(conn) do
    case require_admin(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        {conn, user_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM user", [])
        {conn, msg_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM messages", [])
        {conn, token_stats} = D1.query_one(conn, "DB",
          "SELECT SUM(lifetime_earned) as issued, SUM(lifetime_earned - balance) as spent FROM tokens", [])
        {conn, recent_users} = D1.query(conn, "DB",
          "SELECT u.id, u.email, u.createdAt, p.display_name FROM user u LEFT JOIN profiles p ON p.user_id = u.id ORDER BY u.createdAt DESC LIMIT 10", [])
        {conn, report_count} = D1.query_one(conn, "DB",
          "SELECT COUNT(*) as count FROM reports WHERE status = 'pending'", [])

        stats = %{
          "users" => (user_count || %{})["count"] || 0,
          "messages" => (msg_count || %{})["count"] || 0,
          "tokens_issued" => (token_stats || %{})["issued"] || 0,
          "tokens_spent" => (token_stats || %{})["spent"] || 0,
          "pending_reports" => (report_count || %{})["count"] || 0,
          "recent_users" => recent_users || []
        }
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_admin(auth, stats))
    end
  end

  defp frag_settings(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        {conn, profile} = D1.query_one(conn, "DB",
          "SELECT * FROM profiles WHERE user_id = ?", [auth["userId"]])
        {conn, block_count} = D1.query_one(conn, "DB",
          "SELECT COUNT(*) as count FROM blocks WHERE blocker_id = ?", [auth["userId"]])
        Conn.html(conn, 200, <%= @app_module %>.Views.frag_settings(auth, profile || %{}, (block_count || %{})["count"] || 0))
    end
  end

  # --- Static assets ---

  defp asset_js(conn) do
    conn
    |> Conn.put_resp_header("content-type", "application/javascript; charset=utf-8")
    |> Conn.put_resp_header("cache-control", "public, max-age=3600")
    |> Conn.send_resp(200, <%= @app_module %>.Assets.js())
  end

  defp asset_css(conn) do
    conn
    |> Conn.put_resp_header("content-type", "text/css; charset=utf-8")
    |> Conn.put_resp_header("cache-control", "public, max-age=3600")
    |> Conn.send_resp(200, <%= @app_module %>.Assets.css())
  end

  # --- API handlers ---

  defp api_health(conn) do
    Conn.json(conn, 200, %{"status" => "ok", "runtime" => "atomvm-wasi", "platform" => "dark-phoenix"})
  end

  defp api_location_update(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        lat = body["lat"]
        lng = body["lng"]

        case {lat, lng} do
          {nil, _} -> Conn.json(conn, 400, %{"error" => "lat required"})
          {_, nil} -> Conn.json(conn, 400, %{"error" => "lng required"})
          _ when not is_number(lat) or not is_number(lng) ->
            Conn.json(conn, 400, %{"error" => "lat/lng must be numbers"})
          _ when lat < -90.0 or lat > 90.0 or lng < -180.0 or lng > 180.0 ->
            Conn.json(conn, 400, %{"error" => "lat/lng out of range"})
          _ ->
            {conn, profile} = D1.query_one(conn, "DB",
              "SELECT display_name, avatar_url FROM profiles WHERE user_id = ?", [auth["userId"]])

            display_name = case profile do
              nil -> auth["name"] || "Anonymous"
              p -> p["display_name"] || auth["name"] || "Anonymous"
            end

            avatar = case profile do
              nil -> auth["image"] || ""
              p -> p["avatar_url"] || auth["image"] || ""
            end

            location_data = ElixirWorkers.JSON.encode(%{
              "lat" => lat, "lng" => lng,
              "ts" => body["ts"] || "",
              "user_id" => auth["userId"],
              "display_name" => display_name,
              "avatar_url" => avatar
            })

            conn = KV.put(conn, "LOCATIONS", "loc:" <> auth["userId"], location_data,
              %{"expiration_ttl" => 300})
            Conn.json(conn, 200, %{"ok" => true})
        end
    end
  end

  defp api_nearby(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        qs = conn["query_string"] || ""

        # Parse filter params
        max_dist_str = get_query_param(qs, "max_distance")
        min_age_str = get_query_param(qs, "min_age")
        max_age_str = get_query_param(qs, "max_age")
        body_type_filter = get_query_param(qs, "body_type")
        position_filter = get_query_param(qs, "position")
        tribe_filter = get_query_param(qs, "tribe")

        filters = %{
          "max_distance" => safe_parse_float(max_dist_str),
          "min_age" => safe_parse_int(min_age_str),
          "max_age" => safe_parse_int(max_age_str),
          "body_type" => split_csv(body_type_filter),
          "position" => split_csv(position_filter),
          "tribe" => split_csv(tribe_filter)
        }

        # Get blocked user IDs
        {conn, blocked_rows} = D1.query(conn, "DB",
          "SELECT blocked_id FROM blocks WHERE blocker_id = ? UNION SELECT blocker_id FROM blocks WHERE blocked_id = ?",
          [uid, uid])
        blocked_ids = case blocked_rows do
          nil -> []
          rows -> map_vals(rows, "blocked_id")
        end

        # Get own location for distance calc
        {conn, my_loc_raw} = KV.get(conn, "LOCATIONS", "loc:" <> uid)
        my_loc = case my_loc_raw do
          nil -> nil
          v -> ElixirWorkers.JSON.decode(v)
        end

        {conn, result} = KV.list(conn, "LOCATIONS", %{"prefix" => "loc:"})
        case result do
          nil -> Conn.json(conn, 200, %{"users" => []})
          r ->
            keys = r["keys"] || []
            {conn, locations} = fetch_locations(conn, keys, [], blocked_ids, uid)

            # Enrich with profile data if filters are active
            has_filters = filters["max_distance"] != nil or filters["min_age"] != nil or
                          filters["max_age"] != nil or filters["body_type"] != [] or
                          filters["position"] != [] or filters["tribe"] != []

            if has_filters do
              user_ids = map_vals_key(locations, "user_id")
              {conn, profiles} = fetch_profiles_for_ids(conn, user_ids)
              filtered = apply_filters(locations, profiles, filters, my_loc)
              Conn.json(conn, 200, %{"users" => filtered})
            else
              Conn.json(conn, 200, %{"users" => locations})
            end
        end
    end
  end

  defp fetch_locations(conn, [], acc, _blocked, _self_id), do: {conn, :lists.reverse(acc)}
  defp fetch_locations(conn, [key | rest], acc, blocked, self_id) do
    name = key["name"]
    {conn, value} = KV.get(conn, "LOCATIONS", name)
    case value do
      nil -> fetch_locations(conn, rest, acc, blocked, self_id)
      v ->
        parsed = ElixirWorkers.JSON.decode(v)
        user_id = parsed["user_id"] || ""
        if user_id == self_id or list_member?(blocked, user_id) do
          fetch_locations(conn, rest, acc, blocked, self_id)
        else
          fetch_locations(conn, rest, [parsed | acc], blocked, self_id)
        end
    end
  end

  defp fetch_profiles_for_ids(conn, []), do: {conn, %{}}
  defp fetch_profiles_for_ids(conn, ids) do
    fetch_profiles_acc(conn, ids, %{})
  end

  defp fetch_profiles_acc(conn, [], acc), do: {conn, acc}
  defp fetch_profiles_acc(conn, [id | rest], acc) do
    {conn, profile} = D1.query_one(conn, "DB",
      "SELECT user_id, age, body_type, position, tribe FROM profiles WHERE user_id = ?", [id])
    new_acc = case profile do
      nil -> acc
      p -> put_map(acc, id, p)
    end
    fetch_profiles_acc(conn, rest, new_acc)
  end

  defp put_map(map, key, val) do
    :maps.put(key, val, map)
  end

  defp apply_filters(locations, profiles, filters, my_loc) do
    apply_filters_acc(locations, profiles, filters, my_loc, [])
  end

  defp apply_filters_acc([], _profiles, _filters, _my_loc, acc), do: :lists.reverse(acc)
  defp apply_filters_acc([loc | rest], profiles, filters, my_loc, acc) do
    uid = loc["user_id"] || ""
    profile = case :maps.find(uid, profiles) do
      {:ok, p} -> p
      :error -> %{}
    end

    passes = passes_distance?(loc, my_loc, filters["max_distance"]) and
             passes_age?(profile, filters["min_age"], filters["max_age"]) and
             passes_list_filter?(profile["body_type"], filters["body_type"]) and
             passes_list_filter?(profile["position"], filters["position"]) and
             passes_list_filter?(profile["tribe"], filters["tribe"])

    if passes do
      # Enrich location with profile data for display
      enriched = enrich_location(loc, profile, my_loc)
      apply_filters_acc(rest, profiles, filters, my_loc, [enriched | acc])
    else
      apply_filters_acc(rest, profiles, filters, my_loc, acc)
    end
  end

  defp enrich_location(loc, profile, my_loc) do
    loc2 = case profile["age"] do
      nil -> loc
      age -> put_map(loc, "age", age)
    end
    loc3 = case profile["body_type"] do
      nil -> loc2
      "" -> loc2
      bt -> put_map(loc2, "body_type", bt)
    end
    loc4 = case profile["position"] do
      nil -> loc3
      "" -> loc3
      pos -> put_map(loc3, "position", pos)
    end
    loc5 = case profile["tribe"] do
      nil -> loc4
      "" -> loc4
      tr -> put_map(loc4, "tribe", tr)
    end
    case my_loc do
      nil -> loc5
      _ ->
        dist = haversine_km(my_loc["lat"], my_loc["lng"], loc["lat"], loc["lng"])
        put_map(loc5, "distance_km", round_to(dist, 1))
    end
  end

  defp round_to(val, decimals) when is_float(val) do
    mult = :math.pow(10, decimals)
    round(val * mult) / mult
  end
  defp round_to(val, _), do: val

  defp passes_distance?(_loc, _my_loc, nil), do: true
  defp passes_distance?(_loc, nil, _max), do: true
  defp passes_distance?(loc, my_loc, max_km) do
    dist = haversine_km(my_loc["lat"], my_loc["lng"], loc["lat"], loc["lng"])
    dist <= max_km
  end

  defp passes_age?(_profile, nil, nil), do: true
  defp passes_age?(profile, min_age, max_age) do
    age = profile["age"]
    case age do
      nil -> true
      a when is_integer(a) ->
        above_min = case min_age do
          nil -> true
          m -> a >= m
        end
        below_max = case max_age do
          nil -> true
          m -> a <= m
        end
        above_min and below_max
      _ -> true
    end
  end

  defp passes_list_filter?(_value, []), do: true
  defp passes_list_filter?(nil, _filter), do: true
  defp passes_list_filter?("", _filter), do: true
  defp passes_list_filter?(value, filter) when is_binary(value) do
    normalized = ascii_downcase_str(value)
    list_member?(filter, normalized)
  end
  defp passes_list_filter?(_, _), do: true

  defp ascii_downcase_str(str), do: ascii_dc(str, [])
  defp ascii_dc(<<>>, acc), do: :erlang.list_to_binary(:lists.reverse(acc))
  defp ascii_dc(<<c, rest::binary>>, acc) when c >= ?A and c <= ?Z,
    do: ascii_dc(rest, [c + 32 | acc])
  defp ascii_dc(<<c, rest::binary>>, acc), do: ascii_dc(rest, [c | acc])

  defp safe_parse_int(nil), do: nil
  defp safe_parse_int(""), do: nil
  defp safe_parse_int(str) when is_binary(str) do
    case Integer.parse(str) do
      {n, _} -> n
      :error -> nil
    end
  end
  defp safe_parse_int(_), do: nil

  defp safe_parse_float(nil), do: nil
  defp safe_parse_float(""), do: nil
  defp safe_parse_float(str) when is_binary(str) do
    case Float.parse(str) do
      {f, _} -> f
      :error ->
        case Integer.parse(str) do
          {n, _} -> n * 1.0
          :error -> nil
        end
    end
  end
  defp safe_parse_float(_), do: nil

  defp split_csv(nil), do: []
  defp split_csv(""), do: []
  defp split_csv(str) when is_binary(str) do
    split_csv_acc(str, [], [])
  end
  defp split_csv(_), do: []

  defp split_csv_acc(<<>>, current, acc) do
    item = :erlang.list_to_binary(:lists.reverse(current))
    trimmed = ascii_downcase_str(item)
    case trimmed do
      "" -> :lists.reverse(acc)
      _ -> :lists.reverse([trimmed | acc])
    end
  end
  defp split_csv_acc(<<?,, rest::binary>>, current, acc) do
    item = :erlang.list_to_binary(:lists.reverse(current))
    trimmed = ascii_downcase_str(item)
    case trimmed do
      "" -> split_csv_acc(rest, [], acc)
      _ -> split_csv_acc(rest, [], [trimmed | acc])
    end
  end
  defp split_csv_acc(<<c, rest::binary>>, current, acc) do
    split_csv_acc(rest, [c | current], acc)
  end

  defp map_vals_key([], _key), do: []
  defp map_vals_key([h | t], key) do
    val = h[key]
    case val do
      nil -> map_vals_key(t, key)
      _ -> [val | map_vals_key(t, key)]
    end
  end

  defp list_member?([], _), do: false
  defp list_member?([h | _], h), do: true
  defp list_member?([_ | t], val), do: list_member?(t, val)

  defp map_vals([], _key), do: []
  defp map_vals([h | t], key), do: [h[key] | map_vals(t, key)]

  defp api_profile_get(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        id = conn["path_params"]["id"]
        uid = auth["userId"]
        # Check if blocked
        {conn, block} = D1.query_one(conn, "DB",
          "SELECT 1 as b FROM blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)",
          [uid, id, id, uid])
        if block != nil do
          Conn.json(conn, 403, %{"error" => "blocked"})
        else
          {conn, profile} = D1.query_one(conn, "DB",
            "SELECT user_id, display_name, bio, avatar_url, age, looking_for, body_type, position, tribe, is_verified, created_at FROM profiles WHERE user_id = ?", [id])
          case profile do
            nil -> Conn.json(conn, 404, %{"error" => "not_found"})
            _ ->
              {conn, photos} = D1.query(conn, "DB",
                "SELECT id, url, position FROM profile_photos WHERE user_id = ? ORDER BY position ASC", [id])
              Conn.json(conn, 200, put_map(profile, "photos", photos || []))
          end
        end
    end
  end

  defp api_profile_update(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        display_name = body["display_name"] || ""
        bio = body["bio"] || ""
        avatar_url = body["avatar_url"] || ""
        age = body["age"]
        looking_for = body["looking_for"] || ""
        body_type_val = body["body_type"] || ""
        position = body["position"] || ""
        tribe = body["tribe"] || ""

        # Input validation
        cond do
          byte_size(display_name) > 100 ->
            Conn.json(conn, 400, %{"error" => "display_name too long (max 100)"})
          byte_size(bio) > 500 ->
            Conn.json(conn, 400, %{"error" => "bio too long (max 500)"})
          byte_size(looking_for) > 200 ->
            Conn.json(conn, 400, %{"error" => "looking_for too long (max 200)"})
          is_integer(age) and (age < 18 or age > 120) ->
            Conn.json(conn, 400, %{"error" => "age must be 18-120"})
          true ->
            conn = D1.exec(conn, "DB",
              "INSERT INTO profiles (user_id, display_name, bio, avatar_url, age, looking_for, body_type, position, tribe) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?) ON CONFLICT(user_id) DO UPDATE SET display_name = excluded.display_name, bio = excluded.bio, avatar_url = excluded.avatar_url, age = excluded.age, looking_for = excluded.looking_for, body_type = excluded.body_type, position = excluded.position, tribe = excluded.tribe",
              [auth["userId"], display_name, bio, avatar_url, age, looking_for, body_type_val, position, tribe])
            Conn.json(conn, 200, %{"ok" => true})
        end
    end
  end

  # --- Profile Photos API ---

  defp api_profile_photos_list(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, photos} = D1.query(conn, "DB",
          "SELECT id, url, position, created_at FROM profile_photos WHERE user_id = ? ORDER BY position ASC",
          [uid])
        Conn.json(conn, 200, %{"photos" => photos || []})
    end
  end

  defp api_profile_photos_add(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        url = body["url"] || ""
        uid = auth["userId"]

        cond do
          byte_size(url) == 0 ->
            Conn.json(conn, 400, %{"error" => "url required"})
          byte_size(url) > 5000 ->
            Conn.json(conn, 400, %{"error" => "url too long"})
          true ->
            # Check current count (max 6)
            {conn, count_row} = D1.query_one(conn, "DB",
              "SELECT COUNT(*) as count FROM profile_photos WHERE user_id = ?", [uid])
            count = (count_row || %{})["count"] || 0

            if count >= 6 do
              Conn.json(conn, 400, %{"error" => "maximum 6 photos"})
            else
              # Get next position
              {conn, max_pos} = D1.query_one(conn, "DB",
                "SELECT MAX(position) as max_pos FROM profile_photos WHERE user_id = ?", [uid])
              next_pos = case max_pos do
                nil -> 0
                r -> (r["max_pos"] || -1) + 1
              end

              conn = D1.exec(conn, "DB",
                "INSERT INTO profile_photos (user_id, url, position) VALUES (?, ?, ?)",
                [uid, url, next_pos])

              # If first photo, auto-set as avatar_url
              if count == 0 do
                conn = D1.exec(conn, "DB",
                  "UPDATE profiles SET avatar_url = ? WHERE user_id = ?",
                  [url, uid])
                Conn.json(conn, 201, %{"ok" => true, "position" => next_pos, "avatar_set" => true})
              else
                Conn.json(conn, 201, %{"ok" => true, "position" => next_pos})
              end
            end
        end
    end
  end

  defp api_profile_photos_delete(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        photo_id = conn["path_params"]["id"]
        uid = auth["userId"]

        # Verify ownership and get photo info
        {conn, photo} = D1.query_one(conn, "DB",
          "SELECT id, url, position FROM profile_photos WHERE id = ? AND user_id = ?",
          [photo_id, uid])

        case photo do
          nil ->
            Conn.json(conn, 404, %{"error" => "photo not found"})
          _ ->
            deleted_pos = photo["position"] || 0
            deleted_url = photo["url"] || ""

            # Delete the photo
            conn = D1.exec(conn, "DB",
              "DELETE FROM profile_photos WHERE id = ? AND user_id = ?",
              [photo_id, uid])

            # Reorder remaining photos
            conn = D1.exec(conn, "DB",
              "UPDATE profile_photos SET position = position - 1 WHERE user_id = ? AND position > ?",
              [uid, deleted_pos])

            # If deleted photo was position 0 (primary), update avatar to new primary
            conn = if deleted_pos == 0 do
              {conn, new_primary} = D1.query_one(conn, "DB",
                "SELECT url FROM profile_photos WHERE user_id = ? AND position = 0", [uid])
              new_avatar = case new_primary do
                nil -> ""
                p -> p["url"] || ""
              end
              D1.exec(conn, "DB",
                "UPDATE profiles SET avatar_url = ? WHERE user_id = ?",
                [new_avatar, uid])
            else
              # Check if the deleted photo url was the avatar
              {conn, profile} = D1.query_one(conn, "DB",
                "SELECT avatar_url FROM profiles WHERE user_id = ?", [uid])
              if profile != nil and profile["avatar_url"] == deleted_url do
                {conn, first} = D1.query_one(conn, "DB",
                  "SELECT url FROM profile_photos WHERE user_id = ? AND position = 0", [uid])
                new_avatar = case first do
                  nil -> ""
                  p -> p["url"] || ""
                end
                D1.exec(conn, "DB",
                  "UPDATE profiles SET avatar_url = ? WHERE user_id = ?",
                  [new_avatar, uid])
              else
                conn
              end
            end

            Conn.json(conn, 200, %{"ok" => true})
        end
    end
  end

  defp api_message_send(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        to_id = body["to_id"]
        content = body["content"] || ""
        media_url = body["media_url"] || ""
        message_type = body["message_type"] || "text"

        # Validate message_type
        message_type = if message_type == "image", do: "image", else: "text"

        # For image messages, content can be empty; for text, content is required
        has_content = byte_size(content) > 0
        has_media = byte_size(media_url) > 0

        cond do
          to_id == nil -> Conn.json(conn, 400, %{"error" => "to_id required"})
          not has_content and not has_media -> Conn.json(conn, 400, %{"error" => "content or media required"})
          byte_size(content) > 2000 -> Conn.json(conn, 400, %{"error" => "content too long"})
          to_id == auth["userId"] -> Conn.json(conn, 400, %{"error" => "cannot message yourself"})
          true ->
            uid = auth["userId"]
            # Rate limit: 30 messages per minute
            rl_key = "msg:" <> uid
            case check_rate_limit(conn, rl_key, 30, 60) do
              {:error, conn, _} ->
                Conn.json(conn, 429, %{"error" => "rate_limited", "retry_after" => 60})
              {:ok, conn, _remaining} ->
                # Anti-spam check
                case check_spam(body) do
                  {:spam, _reason} ->
                    Conn.json(conn, 200, %{"sent" => true, "tokens_remaining" => 0})
                  _ ->
                    # Check if blocked
                    {conn, block} = D1.query_one(conn, "DB",
                      "SELECT 1 as b FROM blocks WHERE (blocker_id = ? AND blocked_id = ?) OR (blocker_id = ? AND blocked_id = ?)",
                      [uid, to_id, to_id, uid])

                    if block != nil do
                      Conn.json(conn, 403, %{"error" => "blocked"})
                    else
                      {conn, token_row} = D1.query_one(conn, "DB",
                        "SELECT balance FROM tokens WHERE user_id = ?", [uid])

                      balance = case token_row do
                        nil -> 0
                        r -> r["balance"] || 0
                      end

                      if balance > 0 do
                        # Atomic balance guard prevents TOCTOU race
                        conn = D1.batch(conn, "DB", [
                          %{"sql" => "UPDATE tokens SET balance = balance - 1 WHERE user_id = ? AND balance > 0",
                            "params" => [uid]},
                          %{"sql" => "INSERT INTO messages (from_id, to_id, content, media_url, message_type) VALUES (?, ?, ?, ?, ?)",
                            "params" => [uid, to_id, content, media_url, message_type]}
                        ])
                        Conn.json(conn, 201, %{"sent" => true, "tokens_remaining" => balance - 1})
                      else
                        Conn.json(conn, 402, %{"error" => "insufficient_tokens"})
                      end
                    end
                end
            end
        end
    end
  end

  defp api_conversation(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        {conn, msgs} = D1.query(conn, "DB",
          "SELECT id, from_id, to_id, content, media_url, message_type, read, created_at FROM messages WHERE (from_id = ? AND to_id = ?) OR (from_id = ? AND to_id = ?) ORDER BY id DESC LIMIT 50",
          [uid, other_id, other_id, uid])

        # Check typing indicator via KV (auto-expires after 5s TTL)
        {conn, typing_val} = KV.get(conn, "LOCATIONS", "typing:" <> other_id <> ":" <> uid)
        is_typing = typing_val != nil

        # Reverse to get ASC order (we fetched DESC for LIMIT efficiency)
        reversed = reverse_list(msgs || [])
        Conn.json(conn, 200, %{"messages" => reversed, "typing" => is_typing})
    end
  end

  defp api_conversation_newer(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        qs = conn["query_string"] || ""
        after_id = get_query_param(qs, "after")

        case after_id do
          nil -> Conn.json(conn, 400, %{"error" => "after param required"})
          _ ->
            {conn, msgs} = D1.query(conn, "DB",
              "SELECT id, from_id, to_id, content, media_url, message_type, read, created_at FROM messages WHERE ((from_id = ? AND to_id = ?) OR (from_id = ? AND to_id = ?)) AND id > ? ORDER BY id ASC LIMIT 50",
              [uid, other_id, other_id, uid, after_id])

            # Check typing via KV (auto-expires after 5s TTL)
            {conn, typing_val} = KV.get(conn, "LOCATIONS", "typing:" <> other_id <> ":" <> uid)

            Conn.json(conn, 200, %{"messages" => msgs || [], "typing" => typing_val != nil})
        end
    end
  end

  defp api_conversation_older(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        qs = conn["query_string"] || ""
        before_id = get_query_param(qs, "before")

        case before_id do
          nil -> Conn.json(conn, 400, %{"error" => "before param required"})
          _ ->
            {conn, msgs} = D1.query(conn, "DB",
              "SELECT id, from_id, to_id, content, media_url, message_type, read, created_at FROM messages WHERE ((from_id = ? AND to_id = ?) OR (from_id = ? AND to_id = ?)) AND id < ? ORDER BY id DESC LIMIT 30",
              [uid, other_id, other_id, uid, before_id])

            reversed = reverse_list(msgs || [])
            Conn.json(conn, 200, %{"messages" => reversed})
        end
    end
  end

  defp api_typing(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        conn = KV.put(conn, "LOCATIONS", "typing:" <> uid <> ":" <> other_id, "1",
          %{"expiration_ttl" => 5})
        Conn.json(conn, 200, %{"ok" => true})
    end
  end

  defp api_conversations(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, convos} = D1.query(conn, "DB",
          "SELECT m.content as last_message, m.created_at as last_message_at, m.from_id, m.to_id, p.display_name, p.avatar_url, CASE WHEN m.from_id = ? THEN m.to_id ELSE m.from_id END as other_id, (SELECT COUNT(*) FROM messages m2 WHERE m2.from_id = CASE WHEN m.from_id = ? THEN m.to_id ELSE m.from_id END AND m2.to_id = ? AND m2.read = 0) as unread_count FROM messages m LEFT JOIN profiles p ON p.user_id = CASE WHEN m.from_id = ? THEN m.to_id ELSE m.from_id END WHERE m.id IN (SELECT MAX(id) FROM messages WHERE from_id = ? OR to_id = ? GROUP BY CASE WHEN from_id = ? THEN to_id ELSE from_id END) ORDER BY m.created_at DESC LIMIT 50",
          [uid, uid, uid, uid, uid, uid, uid])

        {conn, unread_total} = D1.query_one(conn, "DB",
          "SELECT COUNT(*) as count FROM messages WHERE to_id = ? AND read = 0", [uid])

        Conn.json(conn, 200, %{
          "conversations" => convos || [],
          "unread_total" => (unread_total || %{})["count"] || 0
        })
    end
  end

  defp api_mark_read(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        other_id = conn["path_params"]["id"]
        uid = auth["userId"]
        conn = D1.exec(conn, "DB",
          "UPDATE messages SET read = 1 WHERE to_id = ? AND from_id = ? AND read = 0",
          [uid, other_id])
        Conn.json(conn, 200, %{"ok" => true})
    end
  end

  defp api_tokens_get(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        {conn, tokens} = D1.query_one(conn, "DB",
          "SELECT * FROM tokens WHERE user_id = ?", [auth["userId"]])
        Conn.json(conn, 200, tokens || %{"balance" => 0})
    end
  end

  defp tier_to_amount("starter"), do: 50
  defp tier_to_amount("popular"), do: 150
  defp tier_to_amount("whale"), do: 500
  defp tier_to_amount(_), do: 0

  defp api_tokens_purchase(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        tier = body["tier"] || ""
        amount = tier_to_amount(tier)

        if amount == 0 do
          Conn.json(conn, 400, %{"error" => "invalid_tier", "valid" => ["starter", "popular", "whale"]})
        else
          uid = auth["userId"]
          {conn, tokens} = D1.query_one(conn, "DB",
            "SELECT balance FROM tokens WHERE user_id = ?", [uid])
          current = case tokens do
            nil -> 0
            t -> t["balance"] || 0
          end
          new_balance = current + amount

          conn = D1.batch(conn, "DB", [
            %{"sql" => "UPDATE tokens SET balance = balance + ?, lifetime_earned = lifetime_earned + ? WHERE user_id = ?",
              "params" => [amount, amount, uid]},
            %{"sql" => "INSERT INTO token_transactions (user_id, type, amount, tier, balance_after) VALUES (?, 'purchase', ?, ?, ?)",
              "params" => [uid, amount, tier, new_balance]}
          ])
          Conn.json(conn, 200, %{"ok" => true, "added" => amount, "balance" => new_balance, "tier" => tier})
        end
    end
  end

  defp api_tokens_daily(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, tokens} = D1.query_one(conn, "DB",
          "SELECT * FROM tokens WHERE user_id = ?", [uid])

        case tokens do
          nil ->
            conn = D1.batch(conn, "DB", [
              %{"sql" => "INSERT INTO tokens (user_id, balance, lifetime_earned, daily_free_remaining, daily_reset_at) VALUES (?, 50, 50, 0, datetime('now', '+1 day'))",
                "params" => [uid]},
              %{"sql" => "INSERT INTO token_transactions (user_id, type, amount, tier, balance_after) VALUES (?, 'signup_bonus', 50, '', 50)",
                "params" => [uid]}
            ])
            Conn.json(conn, 200, %{"ok" => true, "added" => 50, "balance" => 50})
          t ->
            daily_remaining = t["daily_free_remaining"] || 0
            reset_at = t["daily_reset_at"] || ""
            now = conn["_state"]["_now"] || ""

            # Check if reset time has passed (refill daily tokens)
            {daily_remaining, conn} = if byte_size(reset_at) > 0 and byte_size(now) > 0 and now >= reset_at do
              # Reset period has passed, refill
              conn = D1.exec(conn, "DB",
                "UPDATE tokens SET daily_free_remaining = 20, daily_reset_at = datetime('now', '+1 day') WHERE user_id = ?", [uid])
              {20, conn}
            else
              {daily_remaining, conn}
            end

            if daily_remaining > 0 do
              add_amount = min_val(daily_remaining, 20)
              current_balance = t["balance"] || 0
              new_balance = current_balance + add_amount
              conn = D1.batch(conn, "DB", [
                %{"sql" => "UPDATE tokens SET balance = balance + ?, lifetime_earned = lifetime_earned + ?, daily_free_remaining = daily_free_remaining - ?, daily_reset_at = datetime('now', '+1 day') WHERE user_id = ?",
                  "params" => [add_amount, add_amount, add_amount, uid]},
                %{"sql" => "INSERT INTO token_transactions (user_id, type, amount, tier, balance_after) VALUES (?, 'daily_claim', ?, '', ?)",
                  "params" => [uid, add_amount, new_balance]}
              ])
              Conn.json(conn, 200, %{"ok" => true, "added" => add_amount, "balance" => new_balance, "next_reset" => reset_at})
            else
              Conn.json(conn, 409, %{"error" => "already_claimed", "next_reset" => reset_at})
            end
        end
    end
  end

  defp min_val(a, b) when a < b, do: a
  defp min_val(_, b), do: b

  defp api_tokens_history(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, txns} = D1.query(conn, "DB",
          "SELECT id, type, amount, tier, balance_after, created_at FROM token_transactions WHERE user_id = ? ORDER BY created_at DESC LIMIT 50",
          [uid])
        Conn.json(conn, 200, %{"transactions" => txns || []})
    end
  end

  # --- Haversine distance in km ---

  defp haversine_km(lat1, lng1, lat2, lng2) do
    r = 6371.0
    dlat = deg_to_rad(lat2 - lat1)
    dlng = deg_to_rad(lng2 - lng1)
    a = :math.sin(dlat / 2.0) * :math.sin(dlat / 2.0) +
        :math.cos(deg_to_rad(lat1)) * :math.cos(deg_to_rad(lat2)) *
        :math.sin(dlng / 2.0) * :math.sin(dlng / 2.0)
    c = 2.0 * :math.atan2(:math.sqrt(a), :math.sqrt(1.0 - a))
    r * c
  end

  defp deg_to_rad(deg) when is_number(deg), do: deg * 3.141592653589793 / 180.0
  defp deg_to_rad(_), do: 0.0

  defp reverse_list(list), do: reverse_list(list, [])
  defp reverse_list([], acc), do: acc
  defp reverse_list([h | t], acc), do: reverse_list(t, [h | acc])

  defp get_query_param(qs, key) do
    # Parse key=value from query string
    target = key <> "="
    case :binary.match(qs, target) do
      :nomatch -> nil
      {pos, len} ->
        rest = :binary.part(qs, pos + len, byte_size(qs) - pos - len)
        case :binary.match(rest, "&") do
          :nomatch -> rest
          {amp_pos, _} -> :binary.part(rest, 0, amp_pos)
        end
    end
  end

  # --- Moderation APIs ---

  defp api_report(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        reported_id = body["reported_user_id"]
        reason = body["reason"]

        cond do
          reported_id == nil -> Conn.json(conn, 400, %{"error" => "reported_user_id required"})
          reason == nil -> Conn.json(conn, 400, %{"error" => "reason required"})
          true ->
            uid = auth["userId"]
            rl_key = "report:" <> uid
            case check_rate_limit(conn, rl_key, 5, 3600) do
              {:error, conn, _} ->
                Conn.json(conn, 429, %{"error" => "rate_limited", "retry_after" => 3600})
              {:ok, conn, _remaining} ->
                details = body["details"] || ""
                conn = D1.exec(conn, "DB",
                  "INSERT INTO reports (reporter_id, reported_user_id, reason, details) VALUES (?, ?, ?, ?)",
                  [uid, reported_id, reason, details])
                Conn.json(conn, 201, %{"ok" => true})
            end
        end
    end
  end

  defp api_block(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        blocked_id = body["user_id"]

        case blocked_id do
          nil -> Conn.json(conn, 400, %{"error" => "user_id required"})
          _ ->
            uid = auth["userId"]
            if uid == blocked_id do
              Conn.json(conn, 400, %{"error" => "cannot block yourself"})
            else
              conn = D1.exec(conn, "DB",
                "INSERT OR IGNORE INTO blocks (blocker_id, blocked_id) VALUES (?, ?)",
                [uid, blocked_id])
              Conn.json(conn, 200, %{"ok" => true})
            end
        end
    end
  end

  defp api_unblock(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        body = conn["parsed_body"] || %{}
        blocked_id = body["user_id"]

        case blocked_id do
          nil -> Conn.json(conn, 400, %{"error" => "user_id required"})
          _ ->
            uid = auth["userId"]
            conn = D1.exec(conn, "DB",
              "DELETE FROM blocks WHERE blocker_id = ? AND blocked_id = ?",
              [uid, blocked_id])
            Conn.json(conn, 200, %{"ok" => true})
        end
    end
  end

  defp api_blocks_list(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, blocks} = D1.query(conn, "DB",
          "SELECT b.blocked_id as user_id, b.created_at as blocked_at, p.display_name FROM blocks b LEFT JOIN profiles p ON p.user_id = b.blocked_id WHERE b.blocker_id = ? ORDER BY b.created_at DESC",
          [uid])
        Conn.json(conn, 200, %{"blocks" => blocks || []})
    end
  end

  # --- Notifications ---

  defp api_unread_count(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, auth} ->
        uid = auth["userId"]
        {conn, unread} = D1.query_one(conn, "DB",
          "SELECT COUNT(*) as count FROM messages WHERE to_id = ? AND read = 0", [uid])
        Conn.json(conn, 200, %{
          "unread_messages" => (unread || %{})["count"] || 0,
          "unread_notifications" => 0
        })
    end
  end

  # --- Anti-spam ---

  defp api_spam_check(conn) do
    case require_auth_api(conn) do
      {:error, conn} -> conn
      {:ok, conn, _auth} ->
        body = conn["parsed_body"] || %{}
        honeypot = body["honeypot"] || ""
        timing = body["timing_ms"]
        mouse = body["mouse_entropy"]
        scroll = body["scroll_depth"]
        focus = body["form_focus_count"]

        score = 1.0
        score = if byte_size(honeypot) > 0, do: 0.0, else: score
        score = if is_number(timing) and timing < 1000, do: score * 0.3, else: score
        score = if is_number(mouse) and mouse == 0, do: score * 0.5, else: score
        score = if is_number(scroll) and scroll == 0, do: score * 0.7, else: score
        score = if is_number(focus) and focus == 0, do: score * 0.6, else: score

        Conn.json(conn, 200, %{"human" => score > 0.4, "score" => score})
    end
  end

  # --- Public stats (no auth required) ---

  defp api_public_stats(conn) do
    {conn, user_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM user", [])
    {conn, msg_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM messages", [])
    {conn, token_stats} = D1.query_one(conn, "DB",
      "SELECT SUM(lifetime_earned) as issued FROM tokens", [])

    Conn.json(conn, 200, %{
      "users" => (user_count || %{})["count"] || 0,
      "messages" => (msg_count || %{})["count"] || 0,
      "tokens_issued" => (token_stats || %{})["issued"] || 0
    })
  end

  # --- Admin ---

  defp api_admin_stats(conn) do
    case require_admin(conn) do
      {:error, conn} -> conn
      {:ok, conn, _auth} ->
        {conn, user_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM user", [])
        {conn, msg_count} = D1.query_one(conn, "DB", "SELECT COUNT(*) as count FROM messages", [])
        {conn, token_stats} = D1.query_one(conn, "DB",
          "SELECT SUM(lifetime_earned) as issued, SUM(lifetime_earned - balance) as spent FROM tokens", [])
        {conn, report_count} = D1.query_one(conn, "DB",
          "SELECT COUNT(*) as count FROM reports WHERE status = 'pending'", [])

        Conn.json(conn, 200, %{
          "users" => (user_count || %{})["count"] || 0,
          "messages" => (msg_count || %{})["count"] || 0,
          "tokens_issued" => (token_stats || %{})["issued"] || 0,
          "tokens_spent" => (token_stats || %{})["spent"] || 0,
          "pending_reports" => (report_count || %{})["count"] || 0
        })
    end
  end
end
